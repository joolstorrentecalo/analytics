WITH bhr_map AS (

  -- pull most current upload which includes all team members in BambooHR where there is one row per team member (no duplicates)
  -- excludes team members that were deleted from BHR (not in uploaded_row_number_desc = 1)

  SELECT *
  FROM PREP.bamboohr.bamboohr_id_employee_number_mapping_source
  WHERE uploaded_row_number_desc = 1
    
	),
bhr_map_id AS (

  -- create table of BambooHR employee ids and Workday IDs for mapping
  -- this is similar to table prep.workday.map_employee_id but uploaded_row_number_desc = 1 logic in bhr_map CTE excludes deleted records
	
  SELECT DISTINCT 
    employee_id AS bhr_employee_id,
    employee_number AS wk_employee_id
  FROM bhr_map
	
),

bhr_dir_stage AS (

  --create list of last known employment dates for team members in BambooHR that terminated before moving to Workday

  SELECT DISTINCT employee_number AS wk_employee_id,
  	hire_date,
  	termination_date
  FROM bhr_map
  WHERE termination_date <= '2020-12-31' --use Workday data for 2021-01-01 or later
  	AND hire_date <= '2020-12-31'      --use Workday data for 2021-01-01 or later
  	AND wk_employee_id != '11595'      --incorrect hire date in bhr_map, listed as 2020-09-10. Correct date is 2020-06-09
  	OR wk_employee_id = '11202'        --not in Workday and terminated on 2021-10-29 so WHERE clause would have excluded this team member
    
  ),

bhr_status AS (

  --pull all status terminations prior to 2020-12-31

	SELECT bhr_map_id.wk_employee_id,
		sts.effective_date,
		sts.employment_status
	FROM PREP.bamboohr.bamboohr_employment_status_source sts 
	LEFT JOIN bhr_map_id ON sts.employee_id = bhr_map_id.bhr_employee_id 
    WHERE employment_status = 'Terminated'
    AND effective_date <= '2020-12-31'

	),
    
bhr_rehires AS (

  --show BambooHR records that are rehires prior to 2021-01-01
  --rehire = employment_status for the previous effective date = 'Terminated' and current employment_status field != 'Terminated'

	SELECT *,
		IFF(employment_status = 'Terminated', 1, 0) AS is_terminated,
		lead(employment_status) OVER (
			PARTITION BY employee_id ORDER BY effective_date DESC,
				is_terminated DESC
			) AS prior_reason
	FROM PREP.bamboohr.bamboohr_employment_status_source
	WHERE effective_date <= '2020-12-31'
    QUALIFY prior_reason = 'Terminated'
		AND employment_status != 'Terminated'
	ORDER BY employee_id,
		effective_date DESC
	),
bhr_new_hires1 AS (

-- show first non-terminated record for any team members in bhr_rehires CTE so we can capture original hire date

	SELECT sts.*
	FROM PREP.bamboohr.bamboohr_employment_status_source sts
	INNER JOIN bhr_rehires ON sts.employee_id = bhr_rehires.employee_id
	WHERE sts.effective_date <= '2020-12-31'
	  AND sts.employment_Status != 'Terminated' 
    QUALIFY row_number() OVER (
	  PARTITION BY sts.employee_id ORDER BY sts.effective_date ASC
			) = 1
            
	),
    
bhr_new_hires2 AS (

-- show first non-terminated record for any team members not in bhr_rehires CTE

	SELECT sts.*
	FROM PREP.bamboohr.bamboohr_employment_status_source sts
	LEFT JOIN bhr_rehires ON sts.employee_id = bhr_rehires.employee_id
	WHERE sts.effective_date <= '2020-12-31'
		AND sts.employment_status != 'Terminated'
		AND bhr_rehires.employee_id IS NULL
		AND sts.status_id NOT IN (
			'32108', -- not a hire date
			'27971', -- not a hire date
			'29556'  -- not a hire date
			) 
		QUALIFY row_number() OVER (
			PARTITION BY sts.employee_id ORDER BY sts.effective_date ASC
			) = 1
	),
sha AS (

  --workday hires and terminations

	SELECT *
	FROM prep.workday.staffing_history_approved_source
	),
bhr_hires AS (

  -- pull all hire data from BambooHR; use UNION to remove duplicates

  
	SELECT employee_id,
		effective_date
	FROM bhr_new_hires1 -- original hire date for rehires
	
	UNION
	
	SELECT employee_id,
		effective_date
	FROM bhr_rehires    -- rehire date for rehires
	
	UNION
	
	SELECT employee_id,
		effective_date
	FROM bhr_new_hires2  -- hire date for team members that are not rehires
    
	),
hires_stage AS (

-- combine hire data from Workday and BambooHR

	SELECT bhr_map_id.wk_employee_id,
		bhr_hires.effective_date
	FROM bhr_hires -- unioned BHR hire data from status table
	LEFT JOIN bhr_map_id ON bhr_hires.employee_id = bhr_map_id.bhr_employee_id
	
	UNION
	
	SELECT employee_id AS hire_id,
		effective_date AS hire_date
	FROM sha -- workday hires
	WHERE business_process_type IN ('Hire', 'Contract Contingent Worker')
	
	UNION
	
	SELECT wk_employee_id,
		hire_date
	FROM bhr_dir_stage -- BHR hire data from listing
	),
terms_stage
AS (
	SELECT wk_employee_id,
		termination_date
	FROM bhr_dir_stage -- BHR term data from listing
	
	UNION
	
	SELECT employee_id,
		effective_date
	FROM sha           -- Workday terminations
	WHERE business_process_type in ('Termination', 'End Contingent Worker Contract')
	
	UNION
	
	SELECT wk_employee_id,
		effective_date
	FROM bhr_status   -- BHR term data from status table
	
	),
start_date AS (

-- order hires asc with hire_rank
	SELECT wk_employee_id AS hire_id,
		effective_date AS hire_date,
		ROW_NUMBER() OVER (
			PARTITION BY wk_employee_id ORDER BY effective_date ASC
			) AS hire_rank
	FROM hires_stage
    
	),
    
end_date AS (

-- order terminations asc with term_rank
	SELECT wk_employee_id AS term_id,
		termination_date AS term_date,
		ROW_NUMBER() OVER (
			PARTITION BY wk_employee_id ORDER BY termination_date ASC
			) AS term_rank
	FROM terms_stage
    
	),

start_to_end AS (

-- join data based on hire and term rank and employee id

	SELECT hire_id as employee_id,
		hire_rank,
		hire_date,
		term_date,
		term_rank,
		COALESCE(term_date, CURRENT_DATE ()) AS last_date --coalesce current date so we can fan out data based on dates between hire_date and last_date
	FROM start_date
	LEFT JOIN end_date ON hire_id = term_id
		AND hire_rank = term_rank
	)
    
SELECT *
FROM start_to_end
ORDER BY employee_id,
	hire_rank desc


1. 'Not a hire date' means?


